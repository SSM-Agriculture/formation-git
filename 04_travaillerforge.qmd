# Travailler avec une forge {.backgroundTitre}

## Git - un modèle distribué

-   **Dépôt local** : dépôt de l'agent sur son espace de travail (sous
    Cerise ou en local par ex.)
-   **Dépôt distant (remote)** : dépôt correspondant situé sur la forge.

::: callout-note
## Convention

Par défaut, le dépôt distant porte l'alias `origin`
:::

![](img/git_distributed.png){fig-align="center"}

## C'est quoi une forge ?

Définition Wikipédia :  

[En informatique, une forge est un système de gestion et de maintenance collaborative de texte.]{.bolder}

[C'est un espace où on peut archiver du code informatique]{.souligneRouge} (R mais pas que bien sûr) qui offre des fonctionnalités supplémentaires à Git comme :

- la **gestion des tickets** (issues) ;  
- les **merge requests ou pull requests** ;
- **un affichage** plus agréable du dépôt **avec une interface web** ;  
- la possibilité d'ajouter **un wiki** ;  
- **l'intégration et le déploiement continus**...

## Exemples de forges

Les plus connues : [Gitlab](https://gitlab.com), [Github](https://github.com), [Bitbucket](https://bitbucket.org)...

Une forge peut être **interne** ou **externe** à un ministère.

- URL de la forge interne du MASA : [https://forge.agriculture.rie.gouv.fr/gitlab/](https://forge.agriculture.rie.gouv.fr/gitlab/)  

- URL de la forge interne du MTECT : [https://gitlab-forge.din.developpement-durable.gouv.fr/](https://gitlab-forge.din.developpement-durable.gouv.fr/)  

- URL du MTECT sur Github : [https://github.com/MTES-MCT](https://github.com/MTES-MCT)

::: callout-note
## À retenir ! 

- Les forges externes ont vocation à héberger les projets open-source. 
Il s'agit donc d'être très vigilant sur le code déposé sur ces forges
:::

## Dialoguer avec Gitlab ![](img/icone_gitlab.png)

Pour travailler avec Gitlab, il faut mettre en place un mode d'authentification.  

2 modes principaux existent : 

- `SSH`  
- `HTTPS`  

Au MASA, [une procédure de configuration existe et a été validée en mars 2024](https://orion.agriculture/confluence/pages/viewpage.action?pageId=1068303025) 
pour établir la connexion entre Cerise et la forge gitlab interne. 
Celle-ci est basée sur le mode `HTTPS` et utilise le credential helper de Git qui 
évite d'avoir à re-saisir son mot de passe (ou token) à chaque action.

## Les groupes dans les forges Gitlab ![](img/icone_gitlab.png)

- Une forge Gitlab est structurée par **groupe**.  
- Chaque **groupe** est constitué de **projets** (les fameux dépôts distants).  
- Chaque **groupe** est associé à des utilisateurs dont chacun dispose **d'un niveau 
de permissions** sur les projets du groupe et sur le groupe lui-même.  

::: columns
::: {.column width="30%"}
Aperçu des groupes au MASA/SSP :
:::

::: {.column width="70%"}
![](img/gitlab_groupes_ssp.png){fig-align="center"}
:::

::::

## Permissions et rôles dans Gitlab ![](img/icone_gitlab.png)

- Les **permissions** se traduisent par plusieurs **rôles** qui sont détaillés dans la 
documentation de Gitlab(https://docs.gitlab.com/ee/user/permissions.html#project-members-permissions).  

Ce qu'il faut retenir :  

| Rôle       | Permissions                                                                                                                                             |
|------------|---------------------------------------------------------------------------------------------------------------------------------------------------------|
| Owner      | Les propriétaires ont un contrôle total sur le projet ou le groupe.                                                                                     |
| Maintainer | Les mainteneurs ont généralement des droits similaires aux propriétaires, <br>mais ils n'ont pas accès à l'intégralité des paramètres du projet/groupe. |
| Developer  | Les développeurs ont des droits d'écriture sur le projet ou le groupe.                                                                                  |
| Reporter   | Les rapporteurs ont des droits de lecture sur le projet ou le groupe.                                                                                   |
| Guest      | Les invités ont des droits d'accès limités et sont souvent utilisés <br>pour donner un accès en lecture seule à des personnes extérieures au projet.    |                                                                         |

## Le système de ticketing (issues)

**Une issue est une tâche à effectuer** : il peut s’agir tout autant de correctifs à apporter au projet que de fonctionnalités à ajouter.  

Ouvrir une issue depuis Gitlab permet de :   

– **Discuter un point** : il est possible d’échanger à plusieurs dans une
issue pour définir comment la traiter.  
– **Assigner une tâche à une personne** : lorsqu’on crée une issue, on
peut assigner la tâche à une ou plusieurs personnes. Elle s’affiche
alors sur le tableau de bord.  
– **Définir une échéance, classer une issue avec un label** : le tableau de
bord permet alors d’avoir une vision complète des issues en cours.  

## Activer les issues sur la forge interne du MASA ![](img/icone_gitlab.png)

Par défaut, les issues ne sont pas activées à la création d'un dépôt sur la forge Gitlab du MASA.  

Pour les activer, il faut :  

- Cliquer sur `Settings` dans le bandeau de gauche puis `General` 
- Cliquer sur le bouton **Expand** à côté de `Visibility, project features, permissions`  
- Activer les issues :  

![](img/activer_issues.png){fig-align="center"}

- Enregistrer les changements :

![](img/activer_issues_valider.png){fig-align="center"}

## Créer une issue ![](img/icone_gitlab.png)

::: columns
::: {.column width="25%"}
![](img/gitlab_creer_issue.png){fig-align="center"}
![](img/gitlab_creer_issue_bouton.png){fig-align="center"}

:::
::: {.column width="75%"}
Puis renseigner les informations concernant l'issue. 

![](img/gitlab_creer_issue_page.png){fig-align="center"}

:::

::::

## Afficher les issues sous forme de tableau (board) ![](img/icone_gitlab.png)

Si vous utilisez **des labels** pour classer vos issues, Gitlab propose un affichage sous forme de tableau de bord qui permet de faire **un suivi de projet sous forme de tâches**.  

Exemple :  

![](img/gitlab_creer_issue_board.png){fig-align="center"}

## Lier un dépôt local à un dépôt distant (1/2)

**1ère étape commune à toutes les méthodes : création d'un dépôt vide sur la forge Gitlab**

- Cliquez sur le bouton "New project" situé en haut à droite :  

![](img/gitlab_nouveau_depot.png){fig-align="center"}

- Choisir "blank project" :  

![](img/gitlab_projet_vide.png){fig-align="center"}

## Lier un dépôt local à un dépôt distant (2/2)

- Renseigner le nom du projet, éventuellement une courte description, l'espace 
d'appartenance du projet dans la forge, son niveau de visibilité et penser à 
décocher l'option "Initialize repository with a README". Puis cliquer sur "Create Project".  

![](img/gitlab_infos_projet.png){fig-align="center"}

## Lier un dépôt local à un dépôt distant avec RStudio (1/3) ![](img/icone_rstudio.png)

Créer un nouveau projet, puis choisir "Contrôle de version" :  

![](img/gitlab_rstudio_lier_projet.png){fig-align="center"}

## Lier un dépôt local à un dépôt distant avec RStudio (2/3) ![](img/icone_rstudio.png)

Puis choisir "Git" :  


![](img/gitlab_rstudio_lier_gitlab_git.png){fig-align="center"}

## Lier un dépôt local à un dépôt distant avec RStudio (3/3) ![](img/icone_rstudio.png)


::: columns
::: {.column width="60%"}
Puis renseigner :  

- L'URL du dépôt distant (voir ci-contre comment la récupérer) ->   
- Le nom du répertoire du projet  
- Le chemin du dépôt local dans votre espace de travail

:::

::: {.column width="40%"}
![](img/gitlab_copier_coller_URL.png){fig-align="center"}
:::

::::

![](img/gitlab_rstudio_lier_projet_URL.png){fig-align="center"}

## Lier un dépôt local à un dépôt distant avec terminal (1/3) ![](img/icone_terminal.png)

<br>
La méthode à utiliser est différente selon les cas :  

1. **Vous voulez créer un nouveau répertoire** dans votre working directory  
2. **Vous avez déjà un répertoire** dans votre working directory  

<br>

::: {.callout-note icon=false}
## À retenir
Pour vérifier qu'un dépôt local est lié à un dépôt distant, la commande `git remote -v` est très utile car elle renvoit l'URL du dépôt distant s'il existe.
:::

## Lier un dépôt local à un dépôt distant avec terminal (2/3) ![](img/icone_terminal.png)

<br>

[**CAS 1 : création d'un nouveau répertoire**]{.souligneRouge}

- Lancer le terminal dans le répertoire où on souhaite créer le nouveau dossier correspondant au dépôt distant (rappel sur [comment faire](#git-avec-le-terminal))  
- Taper la commande `git clone <URL-depot-distant>`  
  
Par exemple :  
`git clone https://forge.agriculture.rie.gouv.fr/gitlab/damien.dotta/test.git`
- Ouvrir le nouveau répertoire et commencer à y travailler comme d'habitude en y créant un projet, des scripts...

## Lier un dépôt local à un dépôt distant avec terminal (3/3) ![](img/icone_terminal.png)

<br>

[**CAS 2 : un répertoire existe déjà**]{.souligneRouge}

- Lancer le terminal dans le répertoire non versionné que l'on souhaite lié au dépôt distant (rappel sur [comment faire](#git-avec-le-terminal))  
- Taper la commande `git remote add origin <URL-depot-distant>`  
  
Par exemple :  
`git remote add origin https://forge.agriculture.rie.gouv.fr/gitlab/damien.dotta/test.git`


## Lier un dépôt local à un dépôt distant avec gitssp (1/2) ![](img/icone_gitssp.png)

<br>

Le package `gitssp` peut également être utilisé pour effectuer la liaison.  
  
**Avantage :** plusieurs branches distantes (developpement, recette et production) vont être créées en une seule instruction R.  
**Inconvénient :** il y a 1 étape supplémentaire dans les pré-requis.    

- Créer un projet .Rproj dans votre working directory (sans choisir "Contrôle de version")
- Charger le package avec `library(git=ssp)`
- Lancer la fonction R `ajouter_git()`

## Lier un dépôt local à un dépôt distant avec gitssp (2/2) ![](img/icone_gitssp.png)

La fonction `ajouter_git()` comprend 2 arguments :  
  
- `origin` : URL du dépôt distant (obligatoire)  
- `dossier` : chemin vers le projet .Rproj que vous avez crée (facultatif car Si aucun dossier n'est précisé, les opérations vont se dérouler dans le dossier courant)  
  
Par exemple :  
```r
ajouter_git(
  origin = "https://forge.agriculture.rie.gouv.fr/gitlab/damien.dotta/test.git",
  dossier = "~/test/"
)
```

## Récupérer un projet depuis une forge ?

`git clone <URL-depot-distant>`

## Pousser les changements sur la forge avec RStudio ![](img/icone_rstudio.png)

## Pousser les changements sur la forge avec le terminal ![](img/icone_terminal.png)

Pousser les changements du dépôt local vers le dépôt distant :  

`git push <alias> <nom-branche>`

Exemple : `git push origin developpement`

## Pousser les changements sur la forge avec gitssp ![](img/icone_gitssp.png)

## Récupérer les changements en local avec RStudio ![](img/icone_rstudio.png)

## Récupérer les changements en local avec le terminal ![](img/icone_terminal.png)

Récupérer les changements du dépôt distant vers le dépôt local :  

`git pull <alias> <nom-branche>`

Exemple : `git pull origin developpement`

## Récupérer les changements en local avec gitssp ![](img/icone_gitssp.png)

A VENIR

## Définition des branches

![](img/schema_vaches_branches_git.png)

## Quand créer une branche ?

On crée une branche pour :  

- Continuer le développement de manière isolée sans altérer le reste du dépôt  
  -> Pour corriger un bug  
  -> Pour implémenter une nouvelle fonctionnalité  
  -> Pour refactorer le code...

- Isoler les différentes étapes du développement (une branche = un environnement)

## Noms des branches

Concernant le noms des branches, une bonne pratique est d'utiliser la structure suivante :  

```         
<categorie>-<nom>
```

| Catégorie | Signification                                       |
|-----------|-----------------------------------------------------|
| hotfix    | Pour résoudre rapidement des problèmes critiques    |
| bugfix    | Pour résoudre des erreurs/bugs                      |
| feature   | Pour ajouter/supprimer/modifier des fonctionnalités |
| test      | Pour tester une idée expérimentale (hors issue)     |
| issue-X   | Pour faire référence à l'issue n°X                  |


## Créer une branche à partir d'une issue Gitlab ![](img/icone_gitlab.png)

Depuis l'interface Gitlab, on peut directement créer une branche comme ci-dessous :  

![](img/gitlab_creer_branch_depuis_issue.png)

## Fermer une issue à partir d'une branche

Avec les forges Gitlab et Github, la fermeture des issues peut être **automatiquement gérée via les messages de commit**.  

Pour cela, vous pouvez utiliser des [mots-clés](https://docs.gitlab.com/ee/user/project/issues/managing_issues.html#closing-issues-automatically) comme `Close`, `Fix`, `Resolve` ou `Implement` avec le `#numero-issue`.  

Exemple de message de commit : 

``` 
feat: Ajout documentation utilisateurs

Close #31, en lien avec #29
```

## Organisation au DEMESIS

![](img/gitflow_demesis.png)


## Que devienne les branches ?

Les branches permanentes persistent tout au long de la vie du projet.  

Les branches temporaires :  

- Apparaissent et disparaissent au fil de la vie du projet  
- Ont une durée de vie limitée...    
- ... et doivent donc être détruites (manuellement ou suite à une fusion)  

=> voir plus loin dans ce support.


## Créer une nouvelle branche avec RStudio ![](img/icone_rstudio.png)

A VENIR

## Créer une nouvelle branche avec Gitlab ![](img/icone_gitlab.png)

A VENIR

## Créer une nouvelle branche avec le terminal ![](img/icone_terminal.png)
A VENIR

## Créer une nouvelle branche avec gitssp ![](img/icone_gitssp.png)
A VENIR

## Fusionner deux branches avec le terminal ![](img/icone_terminal.png)

A VENIR

## Fusionner deux branches avec Gitlab ![](img/icone_gitlab.png)

A VENIR

## Définition des conflits

Les conflits surviennent généralement lorsque **deux personnes ont modifié les mêmes lignes dans un fichier**, ou si un développeur a supprimé un fichier alors qu'un autre développeur le modifiait. Dans ces cas, **Git ne peut pas déterminer automatiquement la version correcte**.    

**Les conflits n'affectent que le développeur qui effectue le merge**, 
les autres membres de l'équipe ne sont pas conscients du conflit. Git marquera 
le fichier comme étant en conflit et arrêtera le processus de merge.   

**Il incombe alors aux développeurs de résoudre le conflit.**

*Source: [Atlassian](https://www.atlassian.com/fr/git/tutorials/using-branches/merge-conflicts)

## Simulation d'un conflit

::: {.callout-note icon=false}
## Exercice :

1. Dans le projet formation-git, créer une nouvelle branche   
2. Se placer dans la branche, ajouter un programme, l’enregistrer puis commit.
3. Vérifier dans Gitlab les modifications apportées, dans la branche principale et dans la nouvelle branche.
4. Fusionner la nouvelle branche avec la branche principale.
5. Dans RStudio, récupérer les modifications avec un pull.

:::



    On se place dans la même configuration que dans l’application précédente : un mainteneur et deux/trois développeurs
    Le mainteneur modifie le contenu de son fichier, puis commit et push les modifications
    Sans faire de pull préalable, les développeurs modifient également le contenu du fichier du mainteneur, puis commit et push les modifications
    Le push est rejeté pour la même raison que dans l’application précédente : les dépôts ne sont plus synchronisés, il faut pull les changements distants au préalable. Mais cette fois, le pull est également rejeté : il y a un conflit entre l’historique du projet distant et celui du projet local. Git nous indique qu’il faut résoudre le conflit avant de pouvoir modifier l’historique du projet.
    Utiliser l’interface de RStudio pour résoudre le conflit, en choisissant la version du fichier que vous souhaitez conserver, puis commit/push les modifications
    Comme dans l’application précédente, seul le développeur le plus rapide parvient à push. Les autres doivent répéter l’opération.




## Repérer les conflits

Pour délimiter la zone de conflit, Git utilise les annotations suivantes :  

- La ligne qui commence par <<<<<<< marque le début de la zone conflictuelle.  
- Le marqueur ======= représente la frontière entre les deux zones à fusionner.  
- La ligne qui commence par >>>>>>> délimite la fin de la zone conflictuelle.
  
## Éviter au maximum les conflits

Quelques conseils :  

- S'interroger sur la question de l'intersection des modifications et des fichiers potentiellement impactés lors de la planification des tâches
- Les durées de vie des branches doit être la plus courte possible
- Modulariser son code (par ex. sous forme de fonctions)  
- Résoudre les conflits le plus tôt possible et ne pas laisser la situation empirer.  
- Faire des "bons" commits fréquemment

## Supprimer les branches

A VENIR

## Supprimer un dépôt dans Gitlab ![](img/icone_gitlab.png)

A VENIR

## Faire référence à des issues dans les commits

A VENIR



## Créer des tags

A VENIR

## Revenir en arrière avec Gitlab ![](img/icone_gitlab.png)

A VENIR

## Revenir en arrière avec le terminal ![](img/icone_terminal.png)

Git revert, git checkout ...

<p style="text-align: center;">[Git permet de consulter n'importe quel état passé du
dépôt]{.content-box-yellow}</p>

Pour revenir en arrière :

-   Sur l'ensemble du dépôt avec l'identifiant d'un commit :
    `git checkout <commitID>`\
-   Sur un seul fichier : `git checkout <commitID> <file-name>`

Pour revenir au présent : `git checkout <branch-name>`

Pour remonter de 4 commits dans le passé : `git checkout <nom-de-branche~3>`


`git revert`


